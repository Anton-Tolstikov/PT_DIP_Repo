# Random State Generator v2.0 (last updated 2025-11-15)

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, colorchooser
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
import pandas as pd
import os
import sys
from matplotlib import rcParams
from tkinter.font import Font
from datetime import datetime
from typing import Optional, List, Dict, Any, Tuple
import logging
from pathlib import Path
from scipy import stats
from scipy.stats import norm, lognorm, uniform, triang, beta, gamma, pareto, t
import warnings
import json

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Constants
DEFAULT_FONTS = ["Arial", "Tahoma", "Times New Roman", "Calibri", "Roboto"]
DEFAULT_SAMPLE_SIZE = 10000
DEFAULT_MEAN = 0.5
DEFAULT_STD = 0.1
DEFAULT_MIN = 0.0
DEFAULT_MAX = 1.0
DEFAULT_UNIT = "д.ед."
DEFAULT_PARAM_NAME = "Параметр"
WINDOW_SIZE = "1800x1000"
LEFT_FRAME_WIDTH = 400
RIGHT_FRAME_WIDTH = 250
HISTOGRAM_COLOR = "#3388FF"
FIGURE_SIZE = (9, 7)
DPI = 600

# Distribution types with their parameters
DISTRIBUTION_TYPES = {
    "Нормальное": ["mean", "std"],
    "Лог-нормальное": ["mean", "std"],
    "Равномерное": ["min", "max"],
    "Треугольное": ["min", "max", "mode"],
    "Бета": ["alpha", "beta"],
    "Гамма": ["shape", "scale"],
    "Парето": ["shape", "scale"],
    "Стьюдента t": ["df"]
}

# Try to set font, fallback to default if not available
try:
    rcParams['font.family'] = 'Arial'
except Exception:
    rcParams['font.family'] = 'DejaVu Sans'


class DistributionApp:
    """Main application class for generating and analyzing statistical distributions."""

    def __init__(self, root: tk.Tk):
        """Initialize the application."""
        self.root = root
        self.root.title("Random_State_v2.0")
        self.root.geometry(WINDOW_SIZE)

        # Initialize instance variables
        self.hist_color = HISTOGRAM_COLOR
        self.all_parameters: List[Dict[str, Any]] = []
        self.current_font = "Roboto"
        self.data: Optional[pd.DataFrame] = None
        self.output_dir: Optional[str] = None
        self.current_values: Optional[np.ndarray] = None
        self.fig: Optional[plt.Figure] = None
        self.ax: Optional[plt.Axes] = None
        self.canvas: Optional[FigureCanvasTkAgg] = None

        # New variables for Excel data
        self.excel_data: Optional[pd.DataFrame] = None
        self.excel_sheets: List[str] = []
        self.excel_columns: List[str] = []
        self.selected_sheet: str = ""
        self.selected_column: str = ""
        self.loaded_data_values: Optional[np.ndarray] = None

        # Theme selection variable
        self.theme_var = tk.StringVar()

        # Setup application
        self.setup_styles()
        self.setup_ui()
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

        logger.info("Application initialized successfully")

    def setup_ui(self) -> None:
        """Setup the main user interface."""
        try:
            # Create main frames
            # Left scrollable panel
            self.left_container = ttk.Frame(self.root, width=LEFT_FRAME_WIDTH)
            self.left_container.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)

            self.left_canvas = tk.Canvas(self.left_container, highlightthickness=0, borderwidth=0)
            self.left_vscroll = ttk.Scrollbar(self.left_container, orient="vertical", command=self.left_canvas.yview)
            self.left_canvas.configure(yscrollcommand=self.left_vscroll.set)

            self.left_scrollable_frame = ttk.Frame(self.left_canvas)
            self.left_window_id = self.left_canvas.create_window((0, 0), window=self.left_scrollable_frame, anchor="nw")
            self.left_canvas.bind("<Configure>",
                                  lambda e: self.left_canvas.itemconfigure(self.left_window_id, width=e.width))

            self.left_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            self.left_vscroll.pack(side=tk.RIGHT, fill=tk.Y)

            # Update scrollregion when content size changes
            def _update_left_scrollregion(event=None):
                self.left_canvas.configure(scrollregion=self.left_canvas.bbox("all"))

            self.left_scrollable_frame.bind("<Configure>", _update_left_scrollregion)

            # Save API-compatible reference
            self.left_frame = self.left_scrollable_frame

            self.center_frame = ttk.Frame(self.root)
            self.center_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)

            self.right_frame = ttk.Frame(self.root, width=RIGHT_FRAME_WIDTH)
            self.right_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5, pady=5)

            # Setup individual frame components
            self.setup_left_frame()
            self.setup_center_frame()
            self.setup_params_list()

            # Bind mouse wheel to scroll left panel only when cursor is over it
            self.left_canvas.bind("<Enter>", self._bind_left_mousewheel)
            self.left_canvas.bind("<Leave>", self._unbind_left_mousewheel)
            self.left_scrollable_frame.bind("<Enter>", self._bind_left_mousewheel)
            self.left_scrollable_frame.bind("<Leave>", self._unbind_left_mousewheel)

            # Add keyboard shortcuts
            self.root.bind_all("<Control-s>", lambda e: self.save_plot())
            self.root.bind_all("<Control-d>", lambda e: self.save_data())
            self.root.bind_all("<Control-g>", lambda e: self.generate_distribution())
            self.root.bind_all("<Control-l>", lambda e: self.load_excel_file())
            self.root.bind_all("<Control-r>", lambda e: self.clear_data())

        except Exception as e:
            logger.error(f"Failed to setup UI: {e}")
            messagebox.showerror("Ошибка", f"Не удалось создать интерфейс: {e}")

    def on_close(self) -> None:
        """Handle application closure."""
        try:
            if self.fig:
                plt.close(self.fig)
            plt.close('all')
            self.root.destroy()
            logger.info("Application closed successfully")
        except Exception as e:
            logger.error(f"Error during application closure: {e}")
        finally:
            sys.exit(0)

    def _bind_left_mousewheel(self, event=None):
        try:
            if sys.platform.startswith('win') or sys.platform == 'darwin':
                self.left_canvas.bind_all("<MouseWheel>", self._on_left_mousewheel)
            else:
                self.left_canvas.bind_all("<Button-4>", self._on_left_mousewheel_linux_up)
                self.left_canvas.bind_all("<Button-5>", self._on_left_mousewheel_linux_down)
        except Exception as e:
            logger.debug(f"Bind mouse wheel failed: {e}")

    def _unbind_left_mousewheel(self, event=None):
        try:
            if sys.platform.startswith('win') or sys.platform == 'darwin':
                self.left_canvas.unbind_all("<MouseWheel>")
            else:
                self.left_canvas.unbind_all("<Button-4>")
                self.left_canvas.unbind_all("<Button-5>")
        except Exception as e:
            logger.debug(f"Unbind mouse wheel failed: {e}")

    def _on_left_mousewheel_linux_up(self, event):
        try:
            self.left_canvas.yview_scroll(-1, "units")
        except Exception as e:
            logger.debug(f"Linux wheel up failed: {e}")

    def _on_left_mousewheel_linux_down(self, event):
        try:
            self.left_canvas.yview_scroll(1, "units")
        except Exception as e:
            logger.debug(f"Linux wheel down failed: {e}")

    def _on_left_mousewheel(self, event):
        """Scroll the left scrollable panel with mouse wheel when bound on hover."""
        try:
            if sys.platform.startswith('win'):
                step = int(event.delta / 120)
                scroll_units = -step if step != 0 else -1
            elif sys.platform == 'darwin':
                scroll_units = -1 if event.delta > 0 else 1
            else:
                scroll_units = -1 if event.delta > 0 else 1
            self.left_canvas.yview_scroll(scroll_units, "units")
        except Exception as e:
            logger.debug(f"Mouse wheel scroll failed: {e}")

    def setup_styles(self) -> None:
        """Setup application styles and themes."""
        try:
            style = ttk.Style()
            style.theme_use("clam")
            style.configure("TButton", padding=6)
            self.root.configure(bg='SystemButtonFace')
        except Exception as e:
            logger.warning(f"Failed to setup styles: {e}")

    def setup_params_list(self) -> None:
        """Setup the parameters list display."""
        try:
            ttk.Label(self.right_frame, text="Список параметров",
                      font=Font(family=self.current_font, size=10, weight='bold')).pack(pady=5)

            # Treeview with vertical scrollbar
            tree_container = ttk.Frame(self.right_frame)
            tree_container.pack(fill=tk.BOTH, expand=True)

            self.params_tree = ttk.Treeview(tree_container, height=20,
                                            columns=('name', 'date'), show='headings')
            tree_vscroll = ttk.Scrollbar(tree_container, orient="vertical", command=self.params_tree.yview)
            self.params_tree.configure(yscrollcommand=tree_vscroll.set)

            # Configure tree columns
            self.params_tree.heading('#0', text='№')
            self.params_tree.column('#0', width=40, anchor='center')
            self.params_tree.heading('name', text='Название')
            self.params_tree.column('name', width=120)
            self.params_tree.heading('date', text='Дата создания')
            self.params_tree.column('date', width=120)

            self.params_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            tree_vscroll.pack(side=tk.RIGHT, fill=tk.Y)

            # Add distribution analysis button
            ttk.Button(self.right_frame, text="Анализ распределений",
                       command=self.analyze_distributions).pack(fill=tk.X, pady=5)

            # Theme selection
            theme_frame = ttk.LabelFrame(self.right_frame, text="Темы", padding=5)
            theme_frame.pack(fill=tk.X, pady=5)
            ttk.Radiobutton(theme_frame, text="GPN", variable=self.theme_var,
                            value="GPN", command=self.apply_theme).pack(anchor=tk.W)
            ttk.Radiobutton(theme_frame, text="Petrotrace", variable=self.theme_var,
                            value="Petrotrace", command=self.apply_theme).pack(anchor=tk.W)

            # Add keyboard shortcuts info
            shortcuts_frame = ttk.LabelFrame(self.right_frame, text="Горячие клавиши", padding=5)
            shortcuts_frame.pack(fill=tk.X, pady=5)

            shortcuts_text = """Ctrl+S - Сохранить график
Ctrl+D - Сохранить данные  
Ctrl+G - Сгенерировать
Ctrl+L - Загрузить Excel
Ctrl+R - Очистить данные"""

            shortcuts_label = ttk.Label(shortcuts_frame, text=shortcuts_text,
                                        font=Font(family=self.current_font, size=8),
                                        justify=tk.LEFT)
            shortcuts_label.pack(anchor=tk.W)

        except Exception as e:
            logger.error(f"Failed to setup parameters list: {e}")

    def update_params_list(self) -> None:
        """Update the parameters list display."""
        try:
            # Clear existing items
            for item in self.params_tree.get_children():
                self.params_tree.delete(item)

            # Add current parameters
            for i, param in enumerate(self.all_parameters, 1):
                self.params_tree.insert('', 'end', text=str(i),
                                        values=(param['name'], param['timestamp']))

        except Exception as e:
            logger.error(f"Failed to update parameters list: {e}")

    def setup_left_frame(self) -> None:
        """Setup the left control panel."""
        try:
            font_label = Font(family=self.current_font, size=10)

            # Font settings frame
            font_frame = ttk.LabelFrame(self.left_frame, text="Настройки шрифта", padding=10)
            font_frame.pack(fill=tk.X, pady=5)

            ttk.Label(font_frame, text="Выберите шрифт:").pack()
            self.font_combobox = ttk.Combobox(font_frame, values=DEFAULT_FONTS)
            self.font_combobox.set(self.current_font)
            self.font_combobox.pack(fill=tk.X)
            ttk.Button(font_frame, text="Применить шрифт",
                       command=self.apply_font).pack(pady=5)
            ttk.Button(font_frame, text="Выбрать цвет гистограммы",
                       command=self.choose_hist_color).pack(fill=tk.X, pady=2)

            # Excel data loading frame
            excel_frame = ttk.LabelFrame(self.left_frame, text="Загрузка данных Excel", padding=10)
            excel_frame.pack(fill=tk.X, pady=5)

            ttk.Button(excel_frame, text="Загрузить Excel файл",
                       command=self.load_excel_file).pack(fill=tk.X, pady=2)

            # Sheet selection
            ttk.Label(excel_frame, text="Выберите лист:").pack()
            self.sheet_combobox = ttk.Combobox(excel_frame, state="readonly")
            self.sheet_combobox.pack(fill=tk.X)
            self.sheet_combobox.bind('<<ComboboxSelected>>', self.on_sheet_selected)

            # Column selection
            ttk.Label(excel_frame, text="Выберите столбец:").pack()
            self.column_combobox = ttk.Combobox(excel_frame, state="readonly")
            self.column_combobox.pack(fill=tk.X)
            self.column_combobox.bind('<<ComboboxSelected>>', self.on_column_selected)

            # Load data button
            ttk.Button(excel_frame, text="Загрузить данные",
                       command=self.load_excel_data).pack(fill=tk.X, pady=2)

            self.excel_status_label = ttk.Label(excel_frame, text="Файл не загружен",
                                                foreground="gray", wraplength=350)
            self.excel_status_label.pack()

            # Distribution parameters frame
            dist_frame = ttk.LabelFrame(self.left_frame, text="Параметры распределения", padding=10)
            dist_frame.pack(fill=tk.X, pady=5)

            # Distribution type
            ttk.Label(dist_frame, text="Тип распределения:").pack()
            self.dist_type = ttk.Combobox(dist_frame, values=list(DISTRIBUTION_TYPES.keys()))
            self.dist_type.pack(fill=tk.X)
            self.dist_type.current(0)
            self.dist_type.bind('<<ComboboxSelected>>', self.on_distribution_changed)

            # Sample size
            ttk.Label(dist_frame, text="Количество значений:").pack()
            self.sample_size_entry = ttk.Entry(dist_frame)
            self.sample_size_entry.insert(0, str(DEFAULT_SAMPLE_SIZE))
            self.sample_size_entry.pack(fill=tk.X)

            # Parameter inputs frame
            self.params_frame = ttk.Frame(dist_frame)
            self.params_frame.pack(fill=tk.X, pady=5)

            # Initialize parameter inputs
            self.setup_parameter_inputs()

            # Truncation limits
            ttk.Label(dist_frame, text="Ограничение min:").pack()
            self.min_limit_entry = ttk.Entry(dist_frame)
            self.min_limit_entry.pack(fill=tk.X)

            ttk.Label(dist_frame, text="Ограничение max:").pack()
            self.max_limit_entry = ttk.Entry(dist_frame)
            self.max_limit_entry.pack(fill=tk.X)

            # Parameter name and unit
            ttk.Label(dist_frame, text="Название параметра:").pack()
            self.param_name_entry = ttk.Entry(dist_frame)
            self.param_name_entry.insert(0, DEFAULT_PARAM_NAME)
            self.param_name_entry.pack(fill=tk.X)

            ttk.Label(dist_frame, text="Единицы измерения:").pack()
            self.unit_entry = ttk.Entry(dist_frame)
            self.unit_entry.insert(0, DEFAULT_UNIT)
            self.unit_entry.pack(fill=tk.X)

            # Data management frame
            data_frame = ttk.LabelFrame(self.left_frame, text="Управление данными", padding=10)
            data_frame.pack(fill=tk.X, pady=5)

            ttk.Button(data_frame, text="Выберите директорию",
                       command=self.select_directory).pack(fill=tk.X, pady=2)
            self.dir_label = ttk.Label(data_frame, text="Папка не выбрана",
                                       foreground="gray", wraplength=350)
            self.dir_label.pack()

            ttk.Button(data_frame, text="Загрузить файл с линиями",
                       command=self.load_excel).pack(fill=tk.X, pady=5)
            self.excel_label = ttk.Label(data_frame, text="Файл не загружен",
                                         foreground="gray", wraplength=350)
            self.excel_label.pack()

            # Actions frame
            action_frame = ttk.LabelFrame(self.left_frame, text="Действия", padding=10)
            action_frame.pack(fill=tk.X, pady=5)

            ttk.Button(action_frame, text="Сгенерировать",
                       command=self.generate_distribution).pack(fill=tk.X, pady=2)
            ttk.Button(action_frame, text="Создать гистограмму из Excel",
                       command=self.create_histogram_from_excel).pack(fill=tk.X, pady=2)
            ttk.Button(action_frame, text="Сохранить график",
                       command=self.save_plot).pack(fill=tk.X, pady=2)
            ttk.Button(action_frame, text="Сохранить данные",
                       command=self.save_data).pack(fill=tk.X, pady=2)
            ttk.Button(action_frame, text="Сохранить конфигурацию",
                       command=self.save_config).pack(fill=tk.X, pady=2)
            ttk.Button(action_frame, text="Загрузить конфигурацию",
                       command=self.load_config).pack(fill=tk.X, pady=2)
            ttk.Button(action_frame, text="Очистить все данные",
                       command=self.clear_data).pack(fill=tk.X, pady=5)

        except Exception as e:
            logger.error(f"Failed to setup left frame: {e}")
            messagebox.showerror("Ошибка", f"Не удалось создать левую панель: {e}")

    def setup_parameter_inputs(self) -> None:
        """Setup parameter input fields based on distribution type."""
        try:
            # Clear existing widgets
            for widget in self.params_frame.winfo_children():
                widget.destroy()

            dist_type = self.dist_type.get()
            if not dist_type:
                return

            params = DISTRIBUTION_TYPES.get(dist_type, [])

            self.param_entries = {}

            for param in params:
                ttk.Label(self.params_frame, text=f"{param}:").pack()
                entry = ttk.Entry(self.params_frame)
                entry.pack(fill=tk.X)

                # Set default values
                if param == "mean":
                    entry.insert(0, str(DEFAULT_MEAN))
                elif param == "std":
                    entry.insert(0, str(DEFAULT_STD))
                elif param == "min":
                    entry.insert(0, str(DEFAULT_MIN))
                elif param == "max":
                    entry.insert(0, str(DEFAULT_MAX))
                elif param == "mode":
                    entry.insert(0, str((DEFAULT_MIN + DEFAULT_MAX) / 2))
                elif param == "alpha":
                    entry.insert(0, "2.0")
                elif param == "beta":
                    entry.insert(0, "2.0")
                elif param == "shape":
                    entry.insert(0, "2.0")
                elif param == "scale":
                    entry.insert(0, "1.0")
                elif param == "df":
                    entry.insert(0, "10.0")

                self.param_entries[param] = entry

        except Exception as e:
            logger.error(f"Failed to setup parameter inputs: {e}")

    def on_distribution_changed(self, event=None) -> None:
        """Handle distribution type change."""
        try:
            self.setup_parameter_inputs()
        except Exception as e:
            logger.error(f"Failed to handle distribution change: {e}")

    def on_sheet_selected(self, event=None) -> None:
        """Handle sheet selection."""
        try:
            self.selected_sheet = self.sheet_combobox.get()
            if hasattr(self, 'excel_file_path') and self.selected_sheet:
                # Get columns from selected sheet
                sheet_data = pd.read_excel(self.excel_file_path, sheet_name=self.selected_sheet)
                self.excel_columns = sheet_data.select_dtypes(include=[np.number]).columns.tolist()
                self.column_combobox['values'] = self.excel_columns
                if self.excel_columns:
                    self.column_combobox.current(0)
                    self.selected_column = self.excel_columns[0]
        except Exception as e:
            logger.error(f"Failed to handle sheet selection: {e}")

    def on_column_selected(self, event=None) -> None:
        """Handle column selection."""
        try:
            self.selected_column = self.column_combobox.get()
        except Exception as e:
            logger.error(f"Failed to handle column selection: {e}")

    def load_excel_file(self) -> None:
        """Load Excel file and get available sheets."""
        try:
            path = filedialog.askopenfilename(
                filetypes=[("Excel files", "*.xlsx *.xls")]
            )

            if path:
                self.excel_file_path = path

                # Get all sheet names
                excel_file = pd.ExcelFile(path)
                self.excel_sheets = excel_file.sheet_names

                # Update sheet combobox
                self.sheet_combobox['values'] = self.excel_sheets
                if self.excel_sheets:
                    self.sheet_combobox.current(0)
                    self.selected_sheet = self.excel_sheets[0]

                    # Load first sheet data to get columns
                    sheet_data = pd.read_excel(path, sheet_name=self.selected_sheet)
                    self.excel_columns = sheet_data.select_dtypes(include=[np.number]).columns.tolist()

                    self.column_combobox['values'] = self.excel_columns
                    if self.excel_columns:
                        self.column_combobox.current(0)
                        self.selected_column = self.excel_columns[0]

                self.excel_status_label.config(text=f"Файл загружен: {os.path.basename(path)}", foreground="black")
                logger.info(f"Excel file loaded: {path}")

        except Exception as e:
            logger.error(f"Failed to load Excel file: {e}")
            messagebox.showerror("Ошибка", f"Не удалось загрузить Excel файл:\n{e}")

    def load_excel_data(self) -> None:
        """Load data from selected sheet and column."""
        try:
            if not hasattr(self, 'excel_file_path') or not self.selected_sheet or not self.selected_column:
                messagebox.showwarning("Внимание", "Сначала выберите файл, лист и столбец")
                return

            # Load data from selected sheet and column
            sheet_data = pd.read_excel(self.excel_file_path, sheet_name=self.selected_sheet)

            if self.selected_column not in sheet_data.columns:
                messagebox.showerror("Ошибка", f"Столбец '{self.selected_column}' не найден")
                return

            # Extract numeric data
            data_series = pd.to_numeric(sheet_data[self.selected_column], errors='coerce')
            data_series = data_series.dropna()

            if len(data_series) == 0:
                messagebox.showerror("Ошибка", "В выбранном столбце нет числовых данных")
                return

            self.loaded_data_values = data_series.values
            self.excel_status_label.config(text=f"Данные загружены: {len(data_series)} значений", foreground="green")

            # Create histogram from loaded data
            self.create_histogram_from_excel()

            logger.info(f"Excel data loaded: {len(data_series)} values from column '{self.selected_column}'")

        except Exception as e:
            logger.error(f"Failed to load Excel data: {e}")
            messagebox.showerror("Ошибка", f"Не удалось загрузить данные:\n{e}")

    def create_histogram_from_excel(self) -> None:
        """Create histogram from loaded Excel data."""
        try:
            if self.loaded_data_values is None or len(self.loaded_data_values) == 0:
                messagebox.showwarning("Внимание", "Сначала загрузите данные из Excel")
                return

            values = self.loaded_data_values

            # Create parameter data
            param_name = f"Данные_{self.selected_column}" if self.selected_column else "Данные_Excel"
            unit = "ед."

            param_data = {
                'name': param_name,
                'unit': unit,
                'values': values,
                'dist_type': 'Загруженные данные',
                'mean': float(np.mean(values)),
                'std': float(np.std(values)),
                'min': float(np.min(values)),
                'max': float(np.max(values)),
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }

            self.all_parameters.append(param_data)
            self.update_params_list()

            # Update plot
            self._update_plot(param_name, unit, values)

            # Store current values for saving
            self.current_values = values

            logger.info(f"Histogram created from Excel data: {len(values)} values")

        except Exception as e:
            logger.error(f"Failed to create histogram from Excel: {e}")
            messagebox.showerror("Ошибка", f"Не удалось создать гистограмму:\n{e}")

    def setup_center_frame(self) -> None:
        """Setup the center plotting area."""
        try:
            self.fig, self.ax = plt.subplots(figsize=FIGURE_SIZE)
            self.canvas = FigureCanvasTkAgg(self.fig, master=self.center_frame)
            self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        except Exception as e:
            logger.error(f"Failed to setup center frame: {e}")
            messagebox.showerror("Ошибка", f"Не удалось создать область для графиков: {e}")

    def apply_font(self) -> None:
        """Apply the selected font to the application."""
        try:
            new_font = self.font_combobox.get()
            if new_font and new_font in DEFAULT_FONTS:
                self.current_font = new_font
                rcParams['font.family'] = new_font

                if self.fig and self.ax:
                    self.ax.set_title(self.ax.get_title(), fontname=new_font)
                    self.ax.set_xlabel(self.ax.get_xlabel(), fontname=new_font)
                    self.ax.set_ylabel(self.ax.get_ylabel(), fontname=new_font)
                    self.canvas.draw()

                messagebox.showinfo("Успех", f"Шрифт изменен на {new_font}")
                logger.info(f"Font changed to {new_font}")
            else:
                messagebox.showwarning("Внимание", "Выберите корректный шрифт")
        except Exception as e:
            logger.error(f"Failed to apply font: {e}")
            messagebox.showerror("Ошибка", f"Не удалось изменить шрифт: {e}")

    def choose_hist_color(self) -> None:
        """Choose histogram color using RGB palette."""
        try:
            color = colorchooser.askcolor(color=self.hist_color, title="Выбор цвета гистограммы")
            if color and color[1]:
                self.hist_color = color[1]
                if self.current_values is not None:
                    param_name = self.param_name_entry.get() or DEFAULT_PARAM_NAME
                    unit = self.unit_entry.get()
                    self._update_plot(param_name, unit, self.current_values)
        except Exception as e:
            logger.error(f"Failed to choose color: {e}")

    def apply_theme(self) -> None:
        """Apply selected theme to the application (placeholder)."""
        try:
            theme = self.theme_var.get()
            logger.info(f"Theme selected: {theme}")
            # Theme implementation placeholder
        except Exception as e:
            logger.error(f"Failed to apply theme: {e}")

    def select_directory(self) -> None:
        """Select output directory for saving files."""
        try:
            folder = filedialog.askdirectory()
            if folder:
                self.output_dir = folder
                self.dir_label.config(text=folder, foreground="black")
                logger.info(f"Output directory selected: {folder}")
        except Exception as e:
            logger.error(f"Failed to select directory: {e}")
            messagebox.showerror("Ошибка", f"Не удалось выбрать папку: {e}")

    def load_excel(self) -> None:
        """Load Excel or CSV file with reference lines."""
        try:
            path = filedialog.askopenfilename(
                filetypes=[("Excel files", "*.xlsx *.xls"), ("CSV files", "*.csv")]
            )

            if path:
                if path.endswith('.csv'):
                    df = pd.read_csv(path)
                else:
                    df = pd.read_excel(path)

                if "Название" in df.columns and "Значение" in df.columns:
                    self.data = df
                    self.excel_label.config(text=os.path.basename(path), foreground="black")
                    logger.info(f"Reference file loaded successfully: {path}")
                else:
                    messagebox.showerror("Ошибка", "Файл должен содержать столбцы 'Название' и 'Значение'")

        except Exception as e:
            logger.error(f"Failed to load reference file: {e}")
            messagebox.showerror("Ошибка", f"Не удалось загрузить файл:\n{e}")

    def validate_inputs(self) -> tuple:
        """Validate and return input parameters."""
        try:
            dist_type = self.dist_type.get()
            if not dist_type:
                raise ValueError("Выберите тип распределения")

            params = DISTRIBUTION_TYPES.get(dist_type, [])
            param_values = {}

            for param in params:
                if param not in self.param_entries:
                    raise ValueError(f"Параметр {param} не найден")

                value = float(self.param_entries[param].get())
                param_values[param] = value

                # Validate specific parameters
                if param == "std" and value <= 0:
                    raise ValueError("Стандартное отклонение должно быть положительным")
                # Min/Max constraints
                if "min" in param_values and "max" in param_values and param_values["min"] >= param_values["max"]:
                    raise ValueError("Минимум должен быть меньше максимума")
                if param == "alpha" and value <= 0:
                    raise ValueError("Параметр alpha должен быть положительным")
                if param == "beta" and value <= 0:
                    raise ValueError("Параметр beta должен быть положительным")
                if param == "shape" and value <= 0:
                    raise ValueError("Параметр shape должен быть положительным")
                if param == "scale" and value <= 0:
                    raise ValueError("Параметр scale должен быть положительным")
                if param == "df" and value <= 0:
                    raise ValueError("Степени свободы должны быть положительными")

            # Additional constraints for triangular distribution: min < mode < max
            if dist_type == "Треугольное":
                if not (param_values["min"] < param_values["mode"] < param_values["max"]):
                    raise ValueError("Для треугольного распределения требуется: min < mode < max")

            sample_size = int(self.sample_size_entry.get()) if self.sample_size_entry.get() else DEFAULT_SAMPLE_SIZE
            if sample_size <= 0:
                raise ValueError("Количество значений должно быть положительным")
            if sample_size > 1000000:  # Prevent memory issues
                raise ValueError("Количество значений не должно превышать 1,000,000")

            min_limit = float(self.min_limit_entry.get()) if self.min_limit_entry.get() else None
            max_limit = float(self.max_limit_entry.get()) if self.max_limit_entry.get() else None
            if min_limit is not None and max_limit is not None and min_limit >= max_limit:
                raise ValueError("Ограничение min должно быть меньше max")

            return dist_type, param_values, sample_size, min_limit, max_limit

        except ValueError as e:
            raise ValueError(f"Ошибка валидации: {e}")

    def generate_distribution(self) -> None:
        """Generate statistical distribution based on input parameters."""
        try:
            # Validate inputs
            dist_type, param_values, sample_size, min_limit, max_limit = self.validate_inputs()

            # Show progress feedback for large operations
            if sample_size > 10000:
                messagebox.showinfo("Информация", f"Генерация {sample_size:,} значений может занять время...")

            # Generate distribution
            values = self._generate_values(dist_type, param_values, sample_size, min_limit, max_limit)

            if values is None or len(values) == 0:
                messagebox.showerror("Ошибка", "Не удалось сгенерировать значения с заданными параметрами")
                return

            self.current_values = values

            # Create parameter data
            param_name = self.param_name_entry.get() or DEFAULT_PARAM_NAME
            unit = self.unit_entry.get()

            param_data = {
                'name': param_name,
                'unit': unit,
                'values': values,
                'dist_type': dist_type,
                'parameters': param_values,
                'min_limit': min_limit,
                'max_limit': max_limit,
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }

            self.all_parameters.append(param_data)
            self.update_params_list()

            # Update plot
            self._update_plot(param_name, unit, values)

            logger.info(f"Distribution generated successfully: {dist_type}, {len(values)} values")

        except Exception as e:
            logger.error(f"Failed to generate distribution: {e}")
            messagebox.showerror("Ошибка", str(e))

    def _generate_values(self, dist_type: str, param_values: Dict[str, float],
                         sample_size: int, min_limit: Optional[float] = None,
                         max_limit: Optional[float] = None) -> Optional[np.ndarray]:
        """Generate values for the specified distribution type with optional truncation."""
        try:
            def _generate(size: int) -> np.ndarray:
                if dist_type == "Нормальное":
                    return np.random.normal(param_values["mean"], param_values["std"], size)
                elif dist_type == "Лог-нормальное":
                    if param_values["mean"] <= 0:
                        raise ValueError("Среднее значение должно быть положительным для лог-нормального распределения")
                    mu = np.log(param_values["mean"] / np.sqrt(1 + (param_values["std"] / param_values["mean"]) ** 2))
                    sigma = np.sqrt(np.log(1 + (param_values["std"] / param_values["mean"]) ** 2))
                    return np.random.lognormal(mu, sigma, size)
                elif dist_type == "Равномерное":
                    return np.random.uniform(param_values["min"], param_values["max"], size)
                elif dist_type == "Треугольное":
                    return np.random.triangular(param_values["min"], param_values["mode"], param_values["max"], size)
                elif dist_type == "Бета":
                    return np.random.beta(param_values["alpha"], param_values["beta"], size)
                elif dist_type == "Гамма":
                    return np.random.gamma(param_values["shape"], param_values["scale"], size)
                elif dist_type == "Парето":
                    return np.random.pareto(param_values["shape"], size) * param_values["scale"]
                elif dist_type == "Стьюдента t":
                    return np.random.standard_t(param_values["df"], size)
                else:
                    return np.array([])

            values = np.array([])
            attempts = 0
            while len(values) < sample_size and attempts < 100:
                new_values = _generate(sample_size)
                if min_limit is not None:
                    new_values = new_values[new_values >= min_limit]
                if max_limit is not None:
                    new_values = new_values[new_values <= max_limit]
                values = np.concatenate([values, new_values])
                attempts += 1

            if len(values) < sample_size:
                raise ValueError("Не удалось получить достаточное количество значений с заданными ограничениями")

            return values[:sample_size]

        except (ValueError, ZeroDivisionError) as e:
            logger.error(f"Parameter error in {dist_type}: {e}")
            raise
        except Exception as e:
            logger.error(f"Failed to generate values for {dist_type}: {e}")
            return None

    def _update_plot(self, param_name: str, unit: str, values: np.ndarray) -> None:
        """Update the plot with new data."""
        try:
            if not self.ax:
                return

            self.ax.clear()

            # Create histogram with better bin calculation
            if len(values) > 0:
                optimal_bins = min(50, max(10, int(np.sqrt(len(values)))))
                vmin, vmax = float(np.min(values)), float(np.max(values))
                if vmin == vmax:
                    bins = 1
                else:
                    bins = np.linspace(vmin, vmax, optimal_bins + 1)

                self.ax.hist(values, bins=bins, color=self.hist_color,
                             edgecolor="black", alpha=0.7, density=False)

                # Set labels and title
                xlabel = f"{param_name} ({unit})" if unit else param_name
                self.ax.set_title(f"Гистограмма распределения параметра \"{param_name}\"",
                                  fontname=self.current_font, fontsize=12)
                self.ax.set_xlabel(xlabel, fontname=self.current_font, fontsize=10)
                self.ax.set_ylabel("Частота", fontname=self.current_font, fontsize=10)

                # Add grid for better readability
                self.ax.grid(True, alpha=0.3)

                # Add reference lines if data is loaded
                if self.data is not None:
                    self._add_reference_lines()

                # Update canvas
                self.canvas.draw()

        except Exception as e:
            logger.error(f"Failed to update plot: {e}")

    def _add_reference_lines(self) -> None:
        """Add reference lines to the plot."""
        try:
            if not self.ax or self.data is None:
                return

            ylim_top = self.ax.get_ylim()[1]

            for _, row in self.data.iterrows():
                try:
                    x_val = float(row['Значение'])
                    name = str(row['Название'])

                    self.ax.axvline(x_val, color='red', linestyle='--',
                                    linewidth=2, alpha=0.8)
                    self.ax.text(x_val, ylim_top * 0.95, name, rotation=90,
                                 verticalalignment='top', fontsize=10,
                                 fontname=self.current_font, color='red')
                except (ValueError, KeyError) as e:
                    logger.warning(f"Failed to add reference line: {e}")
                    continue

        except Exception as e:
            logger.error(f"Failed to add reference lines: {e}")

    def analyze_distributions(self) -> None:
        """Analyze which distribution best fits the current data."""
        try:
            if self.current_values is None or len(self.current_values) == 0:
                messagebox.showwarning("Внимание", "Сначала загрузите или сгенерируйте данные")
                return

            values = self.current_values

            # Fit different distributions and calculate goodness of fit
            distributions = {
                'Нормальное': norm,
                'Лог-нормальное': lognorm,
                'Равномерное': uniform,
                'Треугольное': triang,
                'Бета': beta,
                'Гамма': gamma,
                'Парето': pareto,
                'Стьюдента t': t
            }

            results = []

            for dist_name, dist_class in distributions.items():
                try:
                    # Choose data array used for fitting and testing
                    test_values = values

                    if dist_name == "Бета":
                        value_range = values.max() - values.min()
                        if value_range == 0:
                            raise ValueError("Нулевой размах данных — бета-распределение неприменимо")
                        test_values = (values - values.min()) / value_range

                    # Fit distribution
                    params = dist_class.fit(test_values)
                    fitted_dist = dist_class(*params)

                    # Calculate goodness of fit using Kolmogorov-Smirnov test
                    ks_statistic, p_value = stats.kstest(test_values, fitted_dist.cdf)

                    # Calculate AIC (Akaike Information Criterion)
                    log_likelihood = np.sum(fitted_dist.logpdf(test_values))
                    aic = 2 * len(params) - 2 * log_likelihood

                    results.append({
                        'distribution': dist_name,
                        'ks_statistic': ks_statistic,
                        'p_value': p_value,
                        'aic': aic,
                        'params': params
                    })

                except Exception as e:
                    logger.warning(f"Failed to fit {dist_name} distribution: {e}")
                    # Add more specific error information
                    if "singular matrix" in str(e).lower():
                        logger.warning(f"{dist_name}: Матрица сингулярна, попробуйте другие параметры")
                    elif "domain error" in str(e).lower():
                        logger.warning(f"{dist_name}: Ошибка области определения, проверьте параметры")
                    continue

            # Sort results by AIC (lower is better) then by KS (lower is better)
            results.sort(key=lambda x: (x['aic'], x['ks_statistic']))

            # Display results
            current_dist = self.dist_type.get()
            current_params = {k: float(v.get()) for k, v in self.param_entries.items()}
            self._show_distribution_analysis(results, current_dist, current_params)

        except Exception as e:
            logger.error(f"Failed to analyze distributions: {e}")
            messagebox.showerror("Ошибка", f"Не удалось проанализировать распределения:\n{e}")

    def _show_distribution_analysis(self, results: List[Dict], original_dist_type: str = None,
                                    original_params: Dict[str, float] = None) -> None:
        """Show distribution analysis results in a new window."""
        try:
            # Create new window
            analysis_window = tk.Toplevel(self.root)
            analysis_window.title("Анализ распределений")
            analysis_window.geometry("800x600")

            # Create text widget
            text_widget = tk.Text(analysis_window, wrap=tk.WORD, font=("Courier", 10))
            text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

            # Add scrollbar
            scrollbar = ttk.Scrollbar(analysis_window, orient=tk.VERTICAL, command=text_widget.yview)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            text_widget.configure(yscrollcommand=scrollbar.set)

            # Format and display results
            text_widget.insert(tk.END, "АНАЛИЗ РАСПРЕДЕЛЕНИЙ\n")
            text_widget.insert(tk.END, "=" * 60 + "\n\n")

            text_widget.insert(tk.END, "Ранжирование по качеству соответствия:\n")
            text_widget.insert(tk.END, "(1 = лучшее соответствие)\n\n")

            for i, result in enumerate(results, 1):
                text_widget.insert(tk.END, f"{i}. {result['distribution']}\n")
                text_widget.insert(tk.END, f"   KS-статистика: {result['ks_statistic']:.4f}\n")
                text_widget.insert(tk.END, f"   p-значение: {result['p_value']:.4f}\n")
                text_widget.insert(tk.END, f"   AIC: {result['aic']:.2f}\n")

                # Display parameters with proper labels
                param_labels = self._get_parameter_labels(result['distribution'], result['params'])
                text_widget.insert(tk.END, f"   Параметры:\n")
                for label, value in param_labels.items():
                    text_widget.insert(tk.END, f"     {label}: {value:.6f}\n")
                text_widget.insert(tk.END, "\n")

            text_widget.insert(tk.END, "Интерпретация:\n")
            text_widget.insert(tk.END, "- KS-статистика: чем меньше, тем лучше\n")
            text_widget.insert(tk.END, "- p-значение: > 0.05 означает хорошее соответствие\n")
            text_widget.insert(tk.END, "- AIC: чем меньше, тем лучше\n\n")

            # Show original parameters if available
            if original_dist_type and original_params:
                text_widget.insert(tk.END, "\nИСХОДНЫЕ ПАРАМЕТРЫ ГЕНЕРАЦИИ:\n")
                text_widget.insert(tk.END, "-" * 40 + "\n")
                text_widget.insert(tk.END, f"Тип распределения: {original_dist_type}\n")
                for param_name, value in original_params.items():
                    text_widget.insert(tk.END, f"  {param_name}: {value}\n")

                # Show parameter mapping explanation
                text_widget.insert(tk.END, "\nСООТВЕТСТВИЕ ПАРАМЕТРОВ:\n")
                text_widget.insert(tk.END, "-" * 30 + "\n")
                mapping_explanation = self._get_parameter_mapping_explanation(original_dist_type)
                text_widget.insert(tk.END, mapping_explanation)
                text_widget.insert(tk.END, "\n")

            text_widget.insert(tk.END, "ОПИСАНИЕ ПАРАМЕТРОВ:\n")
            text_widget.insert(tk.END, "- Нормальное: μ (среднее), σ (стандартное отклонение)\n")
            text_widget.insert(tk.END, "- Лог-нормальное: μ (логарифм среднего), σ (логарифм ст.откл.)\n")
            text_widget.insert(tk.END, "- Равномерное: min (минимум), max (максимум)\n")
            text_widget.insert(tk.END, "- Треугольное: min (минимум), mode (мода), max (максимум)\n")
            text_widget.insert(tk.END, "- Бета: α (альфа), β (бета)\n")
            text_widget.insert(tk.END, "- Гамма: shape (форма), scale (масштаб)\n")
            text_widget.insert(tk.END, "- Парето: shape (форма), scale (масштаб)\n")
            text_widget.insert(tk.END, "- Стьюдента t: df (степени свободы)\n")

            text_widget.configure(state=tk.DISABLED)

            # Add close button
            ttk.Button(analysis_window, text="Закрыть",
                       command=analysis_window.destroy).pack(pady=10)

        except Exception as e:
            logger.error(f"Failed to show distribution analysis: {e}")
            messagebox.showerror("Ошибка", f"Не удалось показать анализ распределений:\n{e}")

    def _get_parameter_labels(self, dist_name: str, params: Tuple) -> Dict[str, float]:
        """Get human-readable parameter labels for a distribution."""
        try:
            if dist_name == "Нормальное":
                return {"μ (среднее)": params[0], "σ (ст.откл.)": params[1]}
            elif dist_name == "Лог-нормальное":
                # For lognormal, scipy returns (shape, loc, scale) where shape is the std of log(X)
                return {"σ (лог.ст.откл.)": params[0], "loc (сдвиг)": params[1], "scale (масштаб)": params[2]}
            elif dist_name == "Равномерное":
                return {"loc (сдвиг)": params[0], "scale (масштаб)": params[1]}
            elif dist_name == "Треугольное":
                return {"c (мода)": params[0], "loc (сдвиг)": params[1], "scale (масштаб)": params[2]}
            elif dist_name == "Бета":
                return {"α (альфа)": params[0], "β (бета)": params[1], "loc (сдвиг)": params[2],
                        "scale (масштаб)": params[3]}
            elif dist_name == "Гамма":
                return {"α (форма)": params[0], "loc (сдвиг)": params[1], "scale (масштаб)": params[2]}
            elif dist_name == "Парето":
                return {"b (форма)": params[0], "loc (сдвиг)": params[1], "scale (масштаб)": params[2]}
            elif dist_name == "Стьюдента t":
                return {"df (степени свободы)": params[0], "loc (сдвиг)": params[1], "scale (масштаб)": params[2]}
            else:
                # Fallback: return numbered parameters
                return {f"Параметр {i + 1}": param for i, param in enumerate(params)}
        except Exception as e:
            logger.error(f"Failed to get parameter labels for {dist_name}: {e}")
            return {f"Параметр {i + 1}": param for i, param in enumerate(params)}

    def _get_parameter_mapping_explanation(self, dist_type: str) -> str:
        """Get explanation of how generation parameters map to fitted parameters."""
        try:
            if dist_type == "Нормальное":
                return ("Генерация: mean, std → Fitting: μ (среднее), σ (ст.откл.)\n"
                        "  Параметры совпадают напрямую")
            elif dist_type == "Лог-нормальное":
                return ("Генерация: mean, std → Fitting: σ (лог.ст.откл.), loc, scale\n"
                        "  σ = sqrt(ln(1 + (std/mean)²)), scale = mean/sqrt(1 + (std/mean)²)")
            elif dist_type == "Равномерное":
                return ("Генерация: min, max → Fitting: loc (сдвиг), scale (масштаб)\n"
                        "  loc = min, scale = max - min")
            elif dist_type == "Треугольное":
                return ("Генерация: min, mode, max → Fitting: c (мода), loc (сдвиг), scale (масштаб)\n"
                        "  c = (mode - min)/(max - min), loc = min, scale = max - min")
            elif dist_type == "Бета":
                return ("Генерация: alpha, beta → Fitting: α, β, loc, scale\n"
                        "  α, β совпадают, loc = 0, scale = 1 (нормализованные данные)")
            elif dist_type == "Гамма":
                return ("Генерация: shape, scale → Fitting: α (форма), loc, scale\n"
                        "  α = shape, scale совпадает")
            elif dist_type == "Парето":
                return ("Генерация: shape, scale → Fitting: b (форма), loc, scale\n"
                        "  b = shape, scale совпадает")
            elif dist_type == "Стьюдента t":
                return ("Генерация: df → Fitting: df (степени свободы), loc, scale\n"
                        "  df совпадает, loc = 0, scale = 1 (стандартизированные данные)")
            else:
                return "Соответствие параметров не определено для данного типа распределения"
        except Exception as e:
            logger.error(f"Failed to get parameter mapping explanation for {dist_type}: {e}")
            return "Ошибка при получении объяснения соответствия параметров"

    def save_plot(self) -> None:
        """Save the current plot to a file."""
        try:
            if self.current_values is None or len(self.current_values) == 0:
                messagebox.showwarning("Внимание", "Сначала сгенерируйте распределение или загрузите данные")
                return

            if not self.output_dir:
                messagebox.showwarning("Внимание", "Сначала выберите папку для сохранения")
                return

            filename = filedialog.asksaveasfilename(
                initialdir=self.output_dir,
                defaultextension=".png",
                filetypes=[
                    ("PNG Image", "*.png"),
                    ("JPEG Image", "*.jpg;*.jpeg"),
                    ("PDF Document", "*.pdf")
                ],
                title="Сохранить график как..."
            )

            if filename:
                self.fig.savefig(filename, dpi=DPI, bbox_inches='tight',
                                 facecolor='white', edgecolor='none')
                messagebox.showinfo("Сохранено", f"График успешно сохранён:\n{filename}")
                logger.info(f"Plot saved: {filename}")

        except Exception as e:
            logger.error(f"Failed to save plot: {e}")
            messagebox.showerror("Ошибка", f"Не удалось сохранить график:\n{e}")

    def save_data(self) -> None:
        """Save the generated data to a file."""
        try:
            if not self.all_parameters:
                messagebox.showwarning("Внимание", "Нет данных для сохранения")
                return

            if not self.output_dir:
                messagebox.showwarning("Внимание", "Сначала выберите папку для сохранения")
                return

            save_option = messagebox.askquestion(
                "Режим сохранения",
                "Сохранить все параметры в один файл? (Нет - сохранить только текущий)",
                icon='question'
            )

            if save_option == 'yes':
                combined_df = self._create_combined_dataframe()
                default_name = f"all_parameters_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
            else:
                param = self.all_parameters[-1]
                col_name = f"{param['name']} ({param['unit']})" if param['unit'] else param['name']
                combined_df = pd.DataFrame({col_name: param['values']})
                combined_df.index = combined_df.index + 1
                combined_df.index.name = '№'
                default_name = f"{param['name']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"

            filename = filedialog.asksaveasfilename(
                initialdir=self.output_dir,
                initialfile=default_name,
                defaultextension=".xlsx",
                filetypes=[("Excel files", "*.xlsx"), ("CSV files", "*.csv")],
                title="Сохранить данные как..."
            )

            if filename:
                self._save_dataframe(combined_df, filename)
                messagebox.showinfo("Сохранено", f"Данные успешно сохранены:\n{filename}")
                logger.info(f"Data saved: {filename}")

        except Exception as e:
            logger.error(f"Failed to save data: {e}")
            messagebox.showerror("Ошибка", f"Не удалось сохранить данные:\n{e}")

    def _create_combined_dataframe(self) -> pd.DataFrame:
        """Create a combined dataframe from all parameters."""
        try:
            df_list = []
            for param in self.all_parameters:
                col_name = f"{param['name']}_{param['unit']}" if param['unit'] else param['name']
                temp_df = pd.DataFrame({col_name: param['values']})
                temp_df.index = temp_df.index + 1
                temp_df.index.name = '№'
                df_list.append(temp_df)

            return pd.concat(df_list, axis=1)

        except Exception as e:
            logger.error(f"Failed to create combined dataframe: {e}")
            raise

    def _save_dataframe(self, df: pd.DataFrame, filename: str) -> None:
        """Save dataframe to file."""
        try:
            if filename.endswith('.csv'):
                df.to_csv(filename, index=True, encoding='utf-8-sig')
            else:
                df.to_excel(filename, index=True, engine='openpyxl')

        except Exception as e:
            logger.error(f"Failed to save dataframe: {e}")
            raise

    def save_config(self) -> None:
        """Save current application configuration to JSON."""
        try:
            config = {
                'hist_color': self.hist_color,
                'theme': self.theme_var.get(),
                'parameters': []
            }

            for param in self.all_parameters:
                param_copy = param.copy()
                if isinstance(param_copy.get('values'), np.ndarray):
                    param_copy['values'] = param_copy['values'].tolist()
                config['parameters'].append(param_copy)

            filename = f"config_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            with open(Path.cwd() / filename, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=4)

            messagebox.showinfo("Сохранено", f"Конфигурация сохранена:\n{filename}")
            logger.info(f"Configuration saved: {filename}")

        except Exception as e:
            logger.error(f"Failed to save configuration: {e}")
            messagebox.showerror("Ошибка", f"Не удалось сохранить конфигурацию:\n{e}")

    def load_config(self) -> None:
        """Load application configuration from JSON."""
        try:
            filename = filedialog.askopenfilename(
                initialdir=Path.cwd(),
                defaultextension=".json",
                filetypes=[("JSON files", "*.json")],
                title="Загрузить конфигурацию"
            )

            if not filename:
                return

            with open(filename, 'r', encoding='utf-8') as f:
                config = json.load(f)

            self.hist_color = config.get('hist_color', HISTOGRAM_COLOR)
            self.theme_var.set(config.get('theme', ''))
            self.apply_theme()

            self.all_parameters.clear()
            for param in config.get('parameters', []):
                param_copy = param.copy()
                if 'values' in param_copy:
                    param_copy['values'] = np.array(param_copy['values'])
                self.all_parameters.append(param_copy)

            self.update_params_list()

            if self.all_parameters:
                last_param = self.all_parameters[-1]
                self.current_values = np.array(last_param.get('values', []))
                self._update_plot(last_param.get('name', ''), last_param.get('unit', ''), self.current_values)

            messagebox.showinfo("Загружено", f"Конфигурация загружена:\n{filename}")
            logger.info(f"Configuration loaded: {filename}")

        except Exception as e:
            logger.error(f"Failed to load configuration: {e}")
            messagebox.showerror("Ошибка", f"Не удалось загрузить конфигурацию:\n{e}")

    def clear_data(self) -> None:
        """Clear all data and reset the application state."""
        try:
            # Clear large arrays to free memory
            for param in self.all_parameters:
                if 'values' in param:
                    del param['values']

            self.all_parameters.clear()
            self.current_values = None
            self.loaded_data_values = None

            if self.ax:
                self.ax.clear()
                self.canvas.draw()

            self.update_params_list()
            messagebox.showinfo("Очистка", "Все данные очищены")
            logger.info("All data cleared")

            # Force garbage collection for large datasets
            import gc
            gc.collect()

        except Exception as e:
            logger.error(f"Failed to clear data: {e}")
            messagebox.showerror("Ошибка", f"Не удалось очистить данные: {e}")


def main():
    """Main entry point for the application."""
    try:
        root = tk.Tk()
        app = DistributionApp(root)
        root.mainloop()
    except Exception as e:
        logger.error(f"Application failed to start: {e}")
        messagebox.showerror("Критическая ошибка", f"Приложение не может запуститься:\n{e}")


if __name__ == '__main__':
    main()
